import { toB64 } from "@mgonetwork/bcs";
import { keccak_256 } from "@noble/hashes/sha3";
import { bech32 } from "bech32";
import { bcs } from "../bcs/index.js";
import { IntentScope, messageWithIntent } from "./intent.js";
import { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_FLAG } from "./signature-scheme.js";
import { toSerializedSignature } from "./signature.js";
const PRIVATE_KEY_SIZE = 32;
const LEGACY_PRIVATE_KEY_SIZE = 64;
const MGO_PRIVATE_KEY_PREFIX = "mgoprivkey";
class BaseSigner {
  /**
   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
   * it ensures that a signed message is tied to a specific purpose and domain separator is provided
   */
  async signWithIntent(bytes, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = keccak_256(intentMessage);
    const signature = toSerializedSignature({
      signature: await this.sign(digest),
      signatureScheme: this.getKeyScheme(),
      publicKey: this.getPublicKey()
    });
    return {
      signature,
      bytes: toB64(bytes)
    };
  }
  /**
   * Signs provided transaction block by calling `signWithIntent()` with a `TransactionData` provided as intent scope
   */
  async signTransactionBlock(bytes) {
    return this.signWithIntent(bytes, IntentScope.TransactionData);
  }
  /**
   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
   */
  async signPersonalMessage(bytes) {
    return this.signWithIntent(
      bcs.ser(["vector", "u8"], bytes).toBytes(),
      IntentScope.PersonalMessage
    );
  }
  /**
   * @deprecated use `signPersonalMessage` instead
   */
  async signMessage(bytes) {
    return this.signPersonalMessage(bytes);
  }
  toMgoAddress() {
    return this.getPublicKey().toMgoAddress();
  }
}
class Keypair extends BaseSigner {
}
function decodeMgoPrivateKey(value) {
  const { prefix, words } = bech32.decode(value);
  if (prefix !== MGO_PRIVATE_KEY_PREFIX) {
    throw new Error("invalid private key prefix");
  }
  const extendedSecretKey = new Uint8Array(bech32.fromWords(words));
  const secretKey = extendedSecretKey.slice(1);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0]];
  return {
    schema: signatureScheme,
    secretKey
  };
}
function encodeMgoPrivateKey(bytes, scheme) {
  if (bytes.length !== PRIVATE_KEY_SIZE) {
    throw new Error("Invalid bytes length");
  }
  const flag = SIGNATURE_SCHEME_TO_FLAG[scheme];
  const privKeyBytes = new Uint8Array(bytes.length + 1);
  privKeyBytes.set([flag]);
  privKeyBytes.set(bytes, 1);
  return bech32.encode(MGO_PRIVATE_KEY_PREFIX, bech32.toWords(privKeyBytes));
}
export {
  BaseSigner,
  Keypair,
  LEGACY_PRIVATE_KEY_SIZE,
  MGO_PRIVATE_KEY_PREFIX,
  PRIVATE_KEY_SIZE,
  decodeMgoPrivateKey,
  encodeMgoPrivateKey
};
//# sourceMappingURL=keypair.js.map
