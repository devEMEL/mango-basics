{"version":3,"sources":["../src/index.ts","../src/b64.ts","../src/hex.ts"],"sourcesContent":["import bs58 from 'bs58';\r\n\r\nimport { fromB64, toB64 } from './b64';\r\nimport { fromHEX, toHEX } from './hex';\r\n\r\nconst MGO_ADDRESS_LENGTH = 32;\r\n\r\nfunction toLittleEndian(bigint: bigint, size: number) {\r\n\tlet result = new Uint8Array(size);\r\n\tlet i = 0;\r\n\twhile (bigint > 0) {\r\n\t\tresult[i] = Number(bigint % BigInt(256));\r\n\t\tbigint = bigint / BigInt(256);\r\n\t\ti += 1;\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nconst toB58 = (buffer: Uint8Array) => bs58.encode(buffer);\r\nconst fromB58 = (str: string) => bs58.decode(str);\r\n\r\n// Re-export all encoding dependencies.\r\nexport { toB58, fromB58, toB64, fromB64, fromHEX, toHEX };\r\n\r\n/**\r\n * Supported encodings.\r\n * Used in `Reader.toString()` as well as in `decodeStr` and `encodeStr` functions.\r\n */\r\nexport type Encoding = 'base58' | 'base64' | 'hex';\r\n\r\n/**\r\n * Allows for array definitions for names.\r\n * @example\r\n * ```\r\n * bcs.registerStructType(['vector', BCS.STRING], ...);\r\n * // equals\r\n * bcs.registerStructType('vector<string>', ...);\r\n * ```\r\n */\r\nexport type TypeName = string | [string, ...(TypeName | string)[]];\r\n\r\n/**\r\n * Class used for reading BCS data chunk by chunk. Meant to be used\r\n * by some wrapper, which will make sure that data is valid and is\r\n * matching the desired format.\r\n *\r\n * @example\r\n * // data for this example is:\r\n * // { a: u8, b: u32, c: bool, d: u64 }\r\n *\r\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\r\n * let field1 = reader.read8();\r\n * let field2 = reader.read32();\r\n * let field3 = reader.read8() === '1'; // bool\r\n * let field4 = reader.read64();\r\n * // ....\r\n *\r\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\r\n * its length using {@link readULEB}. Here's an example:\r\n * @example\r\n * // data encoded: { field: [1, 2, 3, 4, 5] }\r\n * let reader = new BcsReader(\"050102030405\");\r\n * let vec_length = reader.readULEB();\r\n * let elements = [];\r\n * for (let i = 0; i < vec_length; i++) {\r\n *   elements.push(reader.read8());\r\n * }\r\n * console.log(elements); // [1,2,3,4,5]\r\n *\r\n * @param {String} data HEX-encoded data (serialized BCS)\r\n */\r\nexport class BcsReader {\r\n\tprivate dataView: DataView;\r\n\tprivate bytePosition: number = 0;\r\n\r\n\t/**\r\n\t * @param {Uint8Array} data Data to use as a buffer.\r\n\t */\r\n\tconstructor(data: Uint8Array) {\r\n\t\tthis.dataView = new DataView(data.buffer);\r\n\t}\r\n\t/**\r\n\t * Shift current cursor position by `bytes`.\r\n\t *\r\n\t * @param {Number} bytes Number of bytes to\r\n\t * @returns {this} Self for possible chaining.\r\n\t */\r\n\tshift(bytes: number) {\r\n\t\tthis.bytePosition += bytes;\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t * Read U8 value from the buffer and shift cursor by 1.\r\n\t * @returns\r\n\t */\r\n\tread8(): number {\r\n\t\tlet value = this.dataView.getUint8(this.bytePosition);\r\n\t\tthis.shift(1);\r\n\t\treturn value;\r\n\t}\r\n\t/**\r\n\t * Read U16 value from the buffer and shift cursor by 2.\r\n\t * @returns\r\n\t */\r\n\tread16(): number {\r\n\t\tlet value = this.dataView.getUint16(this.bytePosition, true);\r\n\t\tthis.shift(2);\r\n\t\treturn value;\r\n\t}\r\n\t/**\r\n\t * Read U32 value from the buffer and shift cursor by 4.\r\n\t * @returns\r\n\t */\r\n\tread32(): number {\r\n\t\tlet value = this.dataView.getUint32(this.bytePosition, true);\r\n\t\tthis.shift(4);\r\n\t\treturn value;\r\n\t}\r\n\t/**\r\n\t * Read U64 value from the buffer and shift cursor by 8.\r\n\t * @returns\r\n\t */\r\n\tread64(): string {\r\n\t\tlet value1 = this.read32();\r\n\t\tlet value2 = this.read32();\r\n\r\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(8, '0');\r\n\r\n\t\treturn BigInt('0x' + result).toString(10);\r\n\t}\r\n\t/**\r\n\t * Read U128 value from the buffer and shift cursor by 16.\r\n\t */\r\n\tread128(): string {\r\n\t\tlet value1 = BigInt(this.read64());\r\n\t\tlet value2 = BigInt(this.read64());\r\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(16, '0');\r\n\r\n\t\treturn BigInt('0x' + result).toString(10);\r\n\t}\r\n\t/**\r\n\t * Read U128 value from the buffer and shift cursor by 32.\r\n\t * @returns\r\n\t */\r\n\tread256(): string {\r\n\t\tlet value1 = BigInt(this.read128());\r\n\t\tlet value2 = BigInt(this.read128());\r\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(32, '0');\r\n\r\n\t\treturn BigInt('0x' + result).toString(10);\r\n\t}\r\n\t/**\r\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\r\n\t * @param num Number of bytes to read.\r\n\t */\r\n\treadBytes(num: number): Uint8Array {\r\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\r\n\t\tlet value = new Uint8Array(this.dataView.buffer, start, num);\r\n\r\n\t\tthis.shift(num);\r\n\r\n\t\treturn value;\r\n\t}\r\n\t/**\r\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\r\n\t * vector lengths.\r\n\t * @returns {Number} The ULEB value.\r\n\t */\r\n\treadULEB(): number {\r\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\r\n\t\tlet buffer = new Uint8Array(this.dataView.buffer, start);\r\n\t\tlet { value, length } = ulebDecode(buffer);\r\n\r\n\t\tthis.shift(length);\r\n\r\n\t\treturn value;\r\n\t}\r\n\t/**\r\n\t * Read a BCS vector: read a length and then apply function `cb` X times\r\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\r\n\t * @param cb Callback to process elements of vector.\r\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\r\n\t */\r\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\r\n\t\tlet length = this.readULEB();\r\n\t\tlet result = [];\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tresult.push(cb(this, i, length));\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n\r\n/**\r\n * Class used to write BCS data into a buffer. Initializer requires\r\n * some size of a buffer to init; default value for this buffer is 1KB.\r\n *\r\n * Most methods are chainable, so it is possible to write them in one go.\r\n *\r\n * @example\r\n * let serialized = new BcsWriter()\r\n *   .write8(10)\r\n *   .write32(1000000)\r\n *   .write64(10000001000000)\r\n *   .hex();\r\n */\r\n\r\ninterface BcsWriterOptions {\r\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\r\n\tsize?: number;\r\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\r\n\tmaxSize?: number;\r\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\r\n\tallocateSize?: number;\r\n}\r\n\r\nexport class BcsWriter {\r\n\tprivate dataView: DataView;\r\n\tprivate bytePosition: number = 0;\r\n\tprivate size: number;\r\n\tprivate maxSize: number;\r\n\tprivate allocateSize: number;\r\n\r\n\tconstructor({ size = 1024, maxSize, allocateSize = 1024 }: BcsWriterOptions = {}) {\r\n\t\tthis.size = size;\r\n\t\tthis.maxSize = maxSize || size;\r\n\t\tthis.allocateSize = allocateSize;\r\n\t\tthis.dataView = new DataView(new ArrayBuffer(size));\r\n\t}\r\n\r\n\tprivate ensureSizeOrGrow(bytes: number) {\r\n\t\tconst requiredSize = this.bytePosition + bytes;\r\n\t\tif (requiredSize > this.size) {\r\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\r\n\t\t\tif (requiredSize > nextSize) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tthis.size = nextSize;\r\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\r\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\r\n\t\t\tthis.dataView = new DataView(nextBuffer);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Shift current cursor position by `bytes`.\r\n\t *\r\n\t * @param {Number} bytes Number of bytes to\r\n\t * @returns {this} Self for possible chaining.\r\n\t */\r\n\tshift(bytes: number): this {\r\n\t\tthis.bytePosition += bytes;\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t * Write a U8 value into a buffer and shift cursor position by 1.\r\n\t * @param {Number} value Value to write.\r\n\t * @returns {this}\r\n\t */\r\n\twrite8(value: number | bigint): this {\r\n\t\tthis.ensureSizeOrGrow(1);\r\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\r\n\t\treturn this.shift(1);\r\n\t}\r\n\t/**\r\n\t * Write a U16 value into a buffer and shift cursor position by 2.\r\n\t * @param {Number} value Value to write.\r\n\t * @returns {this}\r\n\t */\r\n\twrite16(value: number | bigint): this {\r\n\t\tthis.ensureSizeOrGrow(2);\r\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\r\n\t\treturn this.shift(2);\r\n\t}\r\n\t/**\r\n\t * Write a U32 value into a buffer and shift cursor position by 4.\r\n\t * @param {Number} value Value to write.\r\n\t * @returns {this}\r\n\t */\r\n\twrite32(value: number | bigint): this {\r\n\t\tthis.ensureSizeOrGrow(4);\r\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\r\n\t\treturn this.shift(4);\r\n\t}\r\n\t/**\r\n\t * Write a U64 value into a buffer and shift cursor position by 8.\r\n\t * @param {bigint} value Value to write.\r\n\t * @returns {this}\r\n\t */\r\n\twrite64(value: number | bigint): this {\r\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\r\n\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t * Write a U128 value into a buffer and shift cursor position by 16.\r\n\t *\r\n\t * @param {bigint} value Value to write.\r\n\t * @returns {this}\r\n\t */\r\n\twrite128(value: number | bigint): this {\r\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\r\n\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t * Write a U256 value into a buffer and shift cursor position by 16.\r\n\t *\r\n\t * @param {bigint} value Value to write.\r\n\t * @returns {this}\r\n\t */\r\n\twrite256(value: number | bigint): this {\r\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\r\n\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\r\n\t * written.\r\n\t * @param {Number} value Value to write.\r\n\t * @returns {this}\r\n\t */\r\n\twriteULEB(value: number): this {\r\n\t\tulebEncode(value).forEach((el) => this.write8(el));\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t * Write a vector into a buffer by first writing the vector length and then calling\r\n\t * a callback on each passed value.\r\n\t *\r\n\t * @param {Array<Any>} vector Array of elements to write.\r\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\r\n\t * @returns {this}\r\n\t */\r\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\r\n\t\tthis.writeULEB(vector.length);\r\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds support for iterations over the object.\r\n\t * @returns {Uint8Array}\r\n\t */\r\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\r\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\r\n\t\t\tyield this.dataView.getUint8(i);\r\n\t\t}\r\n\t\treturn this.toBytes();\r\n\t}\r\n\r\n\t/**\r\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\r\n\t * @returns {Uint8Array} Resulting bcs.\r\n\t */\r\n\ttoBytes(): Uint8Array {\r\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\r\n\t}\r\n\r\n\t/**\r\n\t * Represent data as 'hex' or 'base64'\r\n\t * @param encoding Encoding to use: 'base64' or 'hex'\r\n\t */\r\n\ttoString(encoding: Encoding): string {\r\n\t\treturn encodeStr(this.toBytes(), encoding);\r\n\t}\r\n}\r\n\r\n// Helper utility: write number as an ULEB array.\r\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\r\nfunction ulebEncode(num: number): number[] {\r\n\tlet arr = [];\r\n\tlet len = 0;\r\n\r\n\tif (num === 0) {\r\n\t\treturn [0];\r\n\t}\r\n\r\n\twhile (num > 0) {\r\n\t\tarr[len] = num & 0x7f;\r\n\t\tif ((num >>= 7)) {\r\n\t\t\tarr[len] |= 0x80;\r\n\t\t}\r\n\t\tlen += 1;\r\n\t}\r\n\r\n\treturn arr;\r\n}\r\n\r\n// Helper utility: decode ULEB as an array of numbers.\r\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\r\nfunction ulebDecode(arr: number[] | Uint8Array): {\r\n\tvalue: number;\r\n\tlength: number;\r\n} {\r\n\tlet total = 0;\r\n\tlet shift = 0;\r\n\tlet len = 0;\r\n\r\n\t// eslint-disable-next-line no-constant-condition\r\n\twhile (true) {\r\n\t\tlet byte = arr[len];\r\n\t\tlen += 1;\r\n\t\ttotal |= (byte & 0x7f) << shift;\r\n\t\tif ((byte & 0x80) === 0) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tshift += 7;\r\n\t}\r\n\r\n\treturn {\r\n\t\tvalue: total,\r\n\t\tlength: len,\r\n\t};\r\n}\r\n\r\n/**\r\n * Set of methods that allows data encoding/decoding as standalone\r\n * BCS value or a part of a composed structure/vector.\r\n */\r\nexport interface TypeInterface {\r\n\tencode: (\r\n\t\tself: BCS,\r\n\t\tdata: any,\r\n\t\toptions: BcsWriterOptions | undefined,\r\n\t\ttypeParams: TypeName[],\r\n\t) => BcsWriter;\r\n\tdecode: (self: BCS, data: Uint8Array, typeParams: TypeName[]) => any;\r\n\r\n\t_encodeRaw: (\r\n\t\twriter: BcsWriter,\r\n\t\tdata: any,\r\n\t\ttypeParams: TypeName[],\r\n\t\ttypeMap: { [key: string]: TypeName },\r\n\t) => BcsWriter;\r\n\t_decodeRaw: (\r\n\t\treader: BcsReader,\r\n\t\ttypeParams: TypeName[],\r\n\t\ttypeMap: { [key: string]: TypeName },\r\n\t) => any;\r\n}\r\n\r\n/**\r\n * Struct type definition. Used as input format in BcsConfig.types\r\n * as well as an argument type for `bcs.registerStructType`.\r\n */\r\nexport type StructTypeDefinition = {\r\n\t[key: string]: TypeName | StructTypeDefinition;\r\n};\r\n\r\n/**\r\n * Enum type definition. Used as input format in BcsConfig.types\r\n * as well as an argument type for `bcs.registerEnumType`.\r\n *\r\n * Value can be either `string` when invariant has a type or `null`\r\n * when invariant is empty.\r\n *\r\n * @example\r\n * bcs.registerEnumType('Option<T>', {\r\n *   some: 'T',\r\n *   none: null\r\n * });\r\n */\r\nexport type EnumTypeDefinition = {\r\n\t[key: string]: TypeName | StructTypeDefinition | null;\r\n};\r\n\r\n/**\r\n * Configuration that is passed into BCS constructor.\r\n */\r\nexport type BcsConfig = {\r\n\t/**\r\n\t * Defines type name for the vector / array type.\r\n\t * In Move: `vector<T>` or `vector`.\r\n\t */\r\n\tvectorType: string;\r\n\t/**\r\n\t * Address length. Varies depending on a platform and\r\n\t * has to be specified for the `address` type.\r\n\t */\r\n\taddressLength: number;\r\n\r\n\t/**\r\n\t * Custom encoding for address. Supported values are\r\n\t * either 'hex' or 'base64'.\r\n\t */\r\n\taddressEncoding?: 'hex' | 'base64';\r\n\t/**\r\n\t * Opening and closing symbol for type parameters. Can be\r\n\t * any pair of symbols (eg `['(', ')']`); default value follows\r\n\t * Rust and Move: `<` and `>`.\r\n\t */\r\n\tgenericSeparators?: [string, string];\r\n\t/**\r\n\t * Type definitions for the BCS. This field allows spawning\r\n\t * BCS instance from JSON or another prepared configuration.\r\n\t * Optional.\r\n\t */\r\n\ttypes?: {\r\n\t\tstructs?: { [key: string]: StructTypeDefinition };\r\n\t\tenums?: { [key: string]: EnumTypeDefinition };\r\n\t\taliases?: { [key: string]: string };\r\n\t};\r\n\t/**\r\n\t * Whether to auto-register primitive types on launch.\r\n\t */\r\n\twithPrimitives?: boolean;\r\n};\r\n\r\n/**\r\n * BCS implementation for Move types and few additional built-ins.\r\n */\r\nexport class BCS {\r\n\t// Prefefined types constants\r\n\tstatic readonly U8: string = 'u8';\r\n\tstatic readonly U16: string = 'u16';\r\n\tstatic readonly U32: string = 'u32';\r\n\tstatic readonly U64: string = 'u64';\r\n\tstatic readonly U128: string = 'u128';\r\n\tstatic readonly U256: string = 'u256';\r\n\tstatic readonly BOOL: string = 'bool';\r\n\tstatic readonly VECTOR: string = 'vector';\r\n\tstatic readonly ADDRESS: string = 'address';\r\n\tstatic readonly STRING: string = 'string';\r\n\tstatic readonly HEX: string = 'hex-string';\r\n\tstatic readonly BASE58: string = 'base58-string';\r\n\tstatic readonly BASE64: string = 'base64-string';\r\n\r\n\t/**\r\n\t * Map of kind `TypeName => TypeInterface`. Holds all\r\n\t * callbacks for (de)serialization of every registered type.\r\n\t *\r\n\t * If the value stored is a string, it is treated as an alias.\r\n\t */\r\n\tpublic types: Map<string, TypeInterface | string> = new Map();\r\n\r\n\t/**\r\n\t * Stored BcsConfig for the current instance of BCS.\r\n\t */\r\n\tprotected schema: BcsConfig;\r\n\r\n\t/**\r\n\t * Count temp keys to generate a new one when requested.\r\n\t */\r\n\tprotected counter: number = 0;\r\n\r\n\t/**\r\n\t * Name of the key to use for temporary struct definitions.\r\n\t * Returns a temp key + index (for a case when multiple temp\r\n\t * structs are processed).\r\n\t */\r\n\tprivate tempKey() {\r\n\t\treturn `bcs-struct-${++this.counter}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Construct a BCS instance with a prepared schema.\r\n\t *\r\n\t * @param schema A prepared schema with type definitions\r\n\t * @param withPrimitives Whether to register primitive types by default\r\n\t */\r\n\tconstructor(schema: BcsConfig | BCS) {\r\n\t\t// if BCS instance is passed -> clone its schema\r\n\t\tif (schema instanceof BCS) {\r\n\t\t\tthis.schema = schema.schema;\r\n\t\t\tthis.types = new Map(schema.types);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.schema = schema;\r\n\r\n\t\t// Register address type under key 'address'.\r\n\t\tthis.registerAddressType(BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\r\n\t\tthis.registerVectorType(schema.vectorType);\r\n\r\n\t\t// Register struct types if they were passed.\r\n\t\tif (schema.types && schema.types.structs) {\r\n\t\t\tfor (let name of Object.keys(schema.types.structs)) {\r\n\t\t\t\tthis.registerStructType(name, schema.types.structs[name]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Register enum types if they were passed.\r\n\t\tif (schema.types && schema.types.enums) {\r\n\t\t\tfor (let name of Object.keys(schema.types.enums)) {\r\n\t\t\t\tthis.registerEnumType(name, schema.types.enums[name]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Register aliases if they were passed.\r\n\t\tif (schema.types && schema.types.aliases) {\r\n\t\t\tfor (let name of Object.keys(schema.types.aliases)) {\r\n\t\t\t\tthis.registerAlias(name, schema.types.aliases[name]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (schema.withPrimitives !== false) {\r\n\t\t\tregisterPrimitives(this);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Serialize data into bcs.\r\n\t *\r\n\t * @example\r\n\t * bcs.registerVectorType('vector<u8>', 'u8');\r\n\t *\r\n\t * let serialized = BCS\r\n\t *   .set('vector<u8>', [1,2,3,4,5,6])\r\n\t *   .toBytes();\r\n\t *\r\n\t * console.assert(toHex(serialized) === '06010203040506');\r\n\t *\r\n\t * @param type Name of the type to serialize (must be registered) or a struct type.\r\n\t * @param data Data to serialize.\r\n\t * @param size Serialization buffer size. Default 1024 = 1KB.\r\n\t * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\r\n\t */\r\n\tpublic ser(\r\n\t\ttype: TypeName | StructTypeDefinition,\r\n\t\tdata: any,\r\n\t\toptions?: BcsWriterOptions,\r\n\t): BcsWriter {\r\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\r\n\t\t\tconst { name, params } = this.parseTypeName(type);\r\n\t\t\treturn this.getTypeInterface(name).encode(this, data, options, params as string[]);\r\n\t\t}\r\n\r\n\t\t// Quick serialization without registering the type in the main struct.\r\n\t\tif (typeof type === 'object') {\r\n\t\t\tconst key = this.tempKey();\r\n\t\t\tconst temp = new BCS(this);\r\n\t\t\treturn temp.registerStructType(key, type).ser(key, data, options);\r\n\t\t}\r\n\r\n\t\tthrow new Error(`Incorrect type passed into the '.ser()' function. \\n${JSON.stringify(type)}`);\r\n\t}\r\n\r\n\t/**\r\n\t * Deserialize BCS into a JS type.\r\n\t *\r\n\t * @example\r\n\t * let num = bcs.ser('u64', '4294967295').toString('hex');\r\n\t * let deNum = bcs.de('u64', num, 'hex');\r\n\t * console.assert(deNum.toString(10) === '4294967295');\r\n\t *\r\n\t * @param type Name of the type to deserialize (must be registered) or a struct type definition.\r\n\t * @param data Data to deserialize.\r\n\t * @param encoding Optional - encoding to use if data is of type String\r\n\t * @return Deserialized data.\r\n\t */\r\n\tpublic de(\r\n\t\ttype: TypeName | StructTypeDefinition,\r\n\t\tdata: Uint8Array | string,\r\n\t\tencoding?: Encoding,\r\n\t): any {\r\n\t\tif (typeof data === 'string') {\r\n\t\t\tif (encoding) {\r\n\t\t\t\tdata = decodeStr(data, encoding);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('To pass a string to `bcs.de`, specify encoding');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// In case the type specified is already registered.\r\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\r\n\t\t\tconst { name, params } = this.parseTypeName(type);\r\n\t\t\treturn this.getTypeInterface(name).decode(this, data, params as string[]);\r\n\t\t}\r\n\r\n\t\t// Deserialize without registering a type using a temporary clone.\r\n\t\tif (typeof type === 'object') {\r\n\t\t\tconst temp = new BCS(this);\r\n\t\t\tconst key = this.tempKey();\r\n\t\t\treturn temp.registerStructType(key, type).de(key, data, encoding);\r\n\t\t}\r\n\r\n\t\tthrow new Error(`Incorrect type passed into the '.de()' function. \\n${JSON.stringify(type)}`);\r\n\t}\r\n\r\n\t/**\r\n\t * Check whether a `TypeInterface` has been loaded for a `type`.\r\n\t * @param type Name of the type to check.\r\n\t * @returns\r\n\t */\r\n\tpublic hasType(type: string): boolean {\r\n\t\treturn this.types.has(type);\r\n\t}\r\n\r\n\t/**\r\n\t * Create an alias for a type.\r\n\t * WARNING: this can potentially lead to recursion\r\n\t * @param name Alias to use\r\n\t * @param forType Type to reference\r\n\t * @returns\r\n\t *\r\n\t * @example\r\n\t * ```\r\n\t * let bcs = new BCS(getMgoMoveConfig());\r\n\t * bcs.registerAlias('ObjectDigest', BCS.BASE58);\r\n\t * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\r\n\t * ```\r\n\t */\r\n\tpublic registerAlias(name: string, forType: string): BCS {\r\n\t\tthis.types.set(name, forType);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Method to register new types for BCS internal representation.\r\n\t * For each registered type 2 callbacks must be specified and one is optional:\r\n\t *\r\n\t * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\r\n\t * - decodeCb(reader) - write a way to deserialize data with BcsReader;\r\n\t * - validateCb(data) - validate data - either return bool or throw an error\r\n\t *\r\n\t * @example\r\n\t * // our type would be a string that consists only of numbers\r\n\t * bcs.registerType('number_string',\r\n\t *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\r\n\t *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\r\n\t *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\r\n\t * );\r\n\t * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\r\n\t *\r\n\t * @param name\r\n\t * @param encodeCb Callback to encode a value.\r\n\t * @param decodeCb Callback to decode a value.\r\n\t * @param validateCb Optional validator Callback to check type before serialization.\r\n\t */\r\n\tpublic registerType(\r\n\t\ttypeName: TypeName,\r\n\t\tencodeCb: (\r\n\t\t\twriter: BcsWriter,\r\n\t\t\tdata: any,\r\n\t\t\ttypeParams: TypeName[],\r\n\t\t\ttypeMap: { [key: string]: TypeName },\r\n\t\t) => BcsWriter,\r\n\t\tdecodeCb: (\r\n\t\t\treader: BcsReader,\r\n\t\t\ttypeParams: TypeName[],\r\n\t\t\ttypeMap: { [key: string]: TypeName },\r\n\t\t) => any,\r\n\t\tvalidateCb: (data: any) => boolean = () => true,\r\n\t): BCS {\r\n\t\tconst { name, params: generics } = this.parseTypeName(typeName);\r\n\r\n\t\tthis.types.set(name, {\r\n\t\t\tencode(self: BCS, data, options: BcsWriterOptions, typeParams) {\r\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\r\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\r\n\t\t\t\t}, {});\r\n\r\n\t\t\t\treturn this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\r\n\t\t\t},\r\n\t\t\tdecode(self: BCS, data, typeParams) {\r\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\r\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\r\n\t\t\t\t}, {});\r\n\r\n\t\t\t\treturn this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\r\n\t\t\t},\r\n\r\n\t\t\t// these methods should always be used with caution as they require pre-defined\r\n\t\t\t// reader and writer and mainly exist to allow multi-field (de)serialization;\r\n\t\t\t_encodeRaw(writer, data, typeParams, typeMap) {\r\n\t\t\t\tif (validateCb(data)) {\r\n\t\t\t\t\treturn encodeCb.call(this, writer, data, typeParams, typeMap);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`Validation failed for type ${name}, data: ${data}`);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t_decodeRaw(reader, typeParams, typeMap) {\r\n\t\t\t\treturn decodeCb.call(this, reader, typeParams, typeMap);\r\n\t\t\t},\r\n\t\t} as TypeInterface);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Register an address type which is a sequence of U8s of specified length.\r\n\t * @example\r\n\t * bcs.registerAddressType('address', MGO_ADDRESS_LENGTH);\r\n\t * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\r\n\t *\r\n\t * @param name Name of the address type.\r\n\t * @param length Byte length of the address.\r\n\t * @param encoding Encoding to use for the address type\r\n\t * @returns\r\n\t */\r\n\tpublic registerAddressType(name: string, length: number, encoding: Encoding | void = 'hex'): BCS {\r\n\t\tswitch (encoding) {\r\n\t\t\tcase 'base64':\r\n\t\t\t\treturn this.registerType(\r\n\t\t\t\t\tname,\r\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\r\n\t\t\t\t\t\treturn fromB64(data).reduce((writer, el) => writer.write8(el), writer);\r\n\t\t\t\t\t},\r\n\t\t\t\t\tfunction decodeAddress(reader) {\r\n\t\t\t\t\t\treturn toB64(reader.readBytes(length));\r\n\t\t\t\t\t},\r\n\t\t\t\t);\r\n\t\t\tcase 'hex':\r\n\t\t\t\treturn this.registerType(\r\n\t\t\t\t\tname,\r\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\r\n\t\t\t\t\t\treturn fromHEX(data).reduce((writer, el) => writer.write8(el), writer);\r\n\t\t\t\t\t},\r\n\t\t\t\t\tfunction decodeAddress(reader) {\r\n\t\t\t\t\t\treturn toHEX(reader.readBytes(length));\r\n\t\t\t\t\t},\r\n\t\t\t\t);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error('Unsupported encoding! Use either hex or base64');\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Register custom vector type inside the bcs.\r\n\t *\r\n\t * @example\r\n\t * bcs.registerVectorType('vector<T>'); // generic registration\r\n\t * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\r\n\t * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\r\n\t *\r\n\t * @param name Name of the type to register\r\n\t * @param elementType Optional name of the inner type of the vector\r\n\t * @return Returns self for chaining.\r\n\t */\r\n\tprivate registerVectorType(typeName: string): BCS {\r\n\t\tlet { name, params } = this.parseTypeName(typeName);\r\n\t\tif (params.length > 1) {\r\n\t\t\tthrow new Error('Vector can have only one type parameter; got ' + name);\r\n\t\t}\r\n\r\n\t\treturn this.registerType(\r\n\t\t\ttypeName,\r\n\t\t\tfunction encodeVector(\r\n\t\t\t\tthis: BCS,\r\n\t\t\t\twriter: BcsWriter,\r\n\t\t\t\tdata: any[],\r\n\t\t\t\ttypeParams: TypeName[],\r\n\t\t\t\ttypeMap,\r\n\t\t\t) {\r\n\t\t\t\treturn writer.writeVec(data, (writer, el) => {\r\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\r\n\t\t\t\t\tif (!elementType) {\r\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\r\n\t\t\t\t\tif (this.hasType(name)) {\r\n\t\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(this, writer, el, params, typeMap);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!(name in typeMap)) {\r\n\t\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\r\n\r\n\t\t\t\t\treturn this.getTypeInterface(innerName)._encodeRaw.call(\r\n\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\twriter,\r\n\t\t\t\t\t\tel,\r\n\t\t\t\t\t\tinnerParams,\r\n\t\t\t\t\t\ttypeMap,\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tfunction decodeVector(this: BCS, reader: BcsReader, typeParams, typeMap) {\r\n\t\t\t\treturn reader.readVec((reader) => {\r\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\r\n\t\t\t\t\tif (!elementType) {\r\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\r\n\t\t\t\t\tif (this.hasType(name)) {\r\n\t\t\t\t\t\treturn this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!(name in typeMap)) {\r\n\t\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\r\n\r\n\t\t\t\t\treturn this.getTypeInterface(innerName)._decodeRaw.call(\r\n\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\treader,\r\n\t\t\t\t\t\tinnerParams,\r\n\t\t\t\t\t\ttypeMap,\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Safe method to register a custom Move struct. The first argument is a name of the\r\n\t * struct which is only used on the FrontEnd and has no affect on serialization results,\r\n\t * and the second is a struct description passed as an Object.\r\n\t *\r\n\t * The description object MUST have the same order on all of the platforms (ie in Move\r\n\t * or in Rust).\r\n\t *\r\n\t * @example\r\n\t * // Move / Rust struct\r\n\t * // struct Coin {\r\n\t * //   value: u64,\r\n\t * //   owner: vector<u8>, // name // Vec<u8> in Rust\r\n\t * //   is_locked: bool,\r\n\t * // }\r\n\t *\r\n\t * bcs.registerStructType('Coin', {\r\n\t *   value: bcs.U64,\r\n\t *   owner: bcs.STRING,\r\n\t *   is_locked: bcs.BOOL\r\n\t * });\r\n\t *\r\n\t * // Created in Rust with diem/bcs\r\n\t * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\r\n\t * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\r\n\t *  128, 209, 177,   5,  96,  0,  0,\r\n\t *    0,  14,  66, 105, 103, 32, 87,\r\n\t *   97, 108, 108, 101, 116, 32, 71,\r\n\t *  117, 121,   0\r\n\t * ];\r\n\t *\r\n\t * // Let's encode the value as well\r\n\t * let test_set = bcs.ser('Coin', {\r\n\t *   owner: 'Big Wallet Guy',\r\n\t *   value: '412412400000',\r\n\t *   is_locked: false,\r\n\t * });\r\n\t *\r\n\t * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\r\n\t *\r\n\t * @param name Name of the type to register.\r\n\t * @param fields Fields of the struct. Must be in the correct order.\r\n\t * @return Returns BCS for chaining.\r\n\t */\r\n\tpublic registerStructType(typeName: TypeName, fields: StructTypeDefinition): BCS {\r\n\t\t// When an Object is passed, we register it under a new key and store it\r\n\t\t// in the registered type system. This way we allow nested inline definitions.\r\n\t\tfor (let key in fields) {\r\n\t\t\tlet internalName = this.tempKey();\r\n\t\t\tlet value = fields[key];\r\n\r\n\t\t\t// TODO: add a type guard here?\r\n\t\t\tif (!Array.isArray(value) && typeof value !== 'string') {\r\n\t\t\t\tfields[key] = internalName;\r\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet struct = Object.freeze(fields); // Make sure the order doesn't get changed\r\n\r\n\t\t// IMPORTANT: we need to store canonical order of fields for each registered\r\n\t\t// struct so we maintain it and allow developers to use any field ordering in\r\n\t\t// their code (and not cause mismatches based on field order).\r\n\t\tlet canonicalOrder = Object.keys(struct);\r\n\r\n\t\t// Holds generics for the struct definition. At this stage we can check that\r\n\t\t// generic parameter matches the one defined in the struct.\r\n\t\tlet { name: structName, params: generics } = this.parseTypeName(typeName);\r\n\r\n\t\t// Make sure all the types in the fields description are already known\r\n\t\t// and that all the field types are strings.\r\n\t\treturn this.registerType(\r\n\t\t\ttypeName,\r\n\t\t\tfunction encodeStruct(\r\n\t\t\t\tthis: BCS,\r\n\t\t\t\twriter: BcsWriter,\r\n\t\t\t\tdata: { [key: string]: any },\r\n\t\t\t\ttypeParams,\r\n\t\t\t\ttypeMap,\r\n\t\t\t) {\r\n\t\t\t\tif (!data || data.constructor !== Object) {\r\n\t\t\t\t\tthrow new Error(`Expected ${structName} to be an Object, got: ${data}`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (typeParams.length !== generics.length) {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// follow the canonical order when serializing\r\n\t\t\t\tfor (let key of canonicalOrder) {\r\n\t\t\t\t\tif (!(key in data)) {\r\n\t\t\t\t\t\tthrow new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Before deserializing, read the canonical field type.\r\n\t\t\t\t\tconst { name: fieldType, params: fieldParams } = this.parseTypeName(\r\n\t\t\t\t\t\tstruct[key] as TypeName,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// Check whether this type is a generic defined in this struct.\r\n\t\t\t\t\t// If it is -> read the type parameter matching its index.\r\n\t\t\t\t\t// If not - tread as a regular field.\r\n\t\t\t\t\tif (!generics.includes(fieldType)) {\r\n\t\t\t\t\t\tthis.getTypeInterface(fieldType)._encodeRaw.call(\r\n\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\twriter,\r\n\t\t\t\t\t\t\tdata[key],\r\n\t\t\t\t\t\t\tfieldParams,\r\n\t\t\t\t\t\t\ttypeMap,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldType);\r\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\r\n\r\n\t\t\t\t\t\t// If the type from the type parameters already exists\r\n\t\t\t\t\t\t// and known -> proceed with type decoding.\r\n\t\t\t\t\t\tif (this.hasType(name)) {\r\n\t\t\t\t\t\t\tthis.getTypeInterface(name)._encodeRaw.call(\r\n\t\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\t\twriter,\r\n\t\t\t\t\t\t\t\tdata[key],\r\n\t\t\t\t\t\t\t\tparams as string[],\r\n\t\t\t\t\t\t\t\ttypeMap,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Alternatively, if it's a global generic parameter...\r\n\t\t\t\t\t\tif (!(name in typeMap)) {\r\n\t\t\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\r\n\t\t\t\t\t\tthis.getTypeInterface(innerName)._encodeRaw.call(\r\n\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\twriter,\r\n\t\t\t\t\t\t\tdata[key],\r\n\t\t\t\t\t\t\tinnerParams,\r\n\t\t\t\t\t\t\ttypeMap,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn writer;\r\n\t\t\t},\r\n\t\t\tfunction decodeStruct(this: BCS, reader: BcsReader, typeParams, typeMap) {\r\n\t\t\t\tif (typeParams.length !== generics.length) {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet result: { [key: string]: any } = {};\r\n\t\t\t\tfor (let key of canonicalOrder) {\r\n\t\t\t\t\tconst { name: fieldName, params: fieldParams } = this.parseTypeName(\r\n\t\t\t\t\t\tstruct[key] as TypeName,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// if it's not a generic\r\n\t\t\t\t\tif (!generics.includes(fieldName)) {\r\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(fieldName)._decodeRaw.call(\r\n\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\treader,\r\n\t\t\t\t\t\t\tfieldParams as string[],\r\n\t\t\t\t\t\t\ttypeMap,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldName);\r\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\r\n\r\n\t\t\t\t\t\t// If the type from the type parameters already exists\r\n\t\t\t\t\t\t// and known -> proceed with type decoding.\r\n\t\t\t\t\t\tif (this.hasType(name)) {\r\n\t\t\t\t\t\t\tresult[key] = this.getTypeInterface(name)._decodeRaw.call(\r\n\t\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\t\treader,\r\n\t\t\t\t\t\t\t\tparams,\r\n\t\t\t\t\t\t\t\ttypeMap,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!(name in typeMap)) {\r\n\t\t\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\r\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(innerName)._decodeRaw.call(\r\n\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\treader,\r\n\t\t\t\t\t\t\tinnerParams,\r\n\t\t\t\t\t\t\ttypeMap,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t},\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Safe method to register custom enum type where each invariant holds the value of another type.\r\n\t * @example\r\n\t * bcs.registerStructType('Coin', { value: 'u64' });\r\n\t * bcs.registerEnumType('MyEnum', {\r\n\t *  single: 'Coin',\r\n\t *  multi: 'vector<Coin>',\r\n\t *  empty: null\r\n\t * });\r\n\t *\r\n\t * console.log(\r\n\t *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\r\n\t *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\r\n\t * )\r\n\t *\r\n\t * // and serialization\r\n\t * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\r\n\t * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\r\n\t *\r\n\t * @param name\r\n\t * @param variants\r\n\t */\r\n\tpublic registerEnumType(typeName: TypeName, variants: EnumTypeDefinition): BCS {\r\n\t\t// When an Object is passed, we register it under a new key and store it\r\n\t\t// in the registered type system. This way we allow nested inline definitions.\r\n\t\tfor (let key in variants) {\r\n\t\t\tlet internalName = this.tempKey();\r\n\t\t\tlet value = variants[key];\r\n\r\n\t\t\tif (value !== null && !Array.isArray(value) && typeof value !== 'string') {\r\n\t\t\t\tvariants[key] = internalName;\r\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet struct = Object.freeze(variants); // Make sure the order doesn't get changed\r\n\r\n\t\t// IMPORTANT: enum is an ordered type and we have to preserve ordering in BCS\r\n\t\tlet canonicalOrder = Object.keys(struct);\r\n\r\n\t\t// Parse type parameters in advance to know the index of each generic parameter.\r\n\t\tlet { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\r\n\r\n\t\treturn this.registerType(\r\n\t\t\ttypeName,\r\n\t\t\tfunction encodeEnum(\r\n\t\t\t\tthis: BCS,\r\n\t\t\t\twriter: BcsWriter,\r\n\t\t\t\tdata: { [key: string]: any | null },\r\n\t\t\t\ttypeParams,\r\n\t\t\t\ttypeMap,\r\n\t\t\t) {\r\n\t\t\t\tif (!data) {\r\n\t\t\t\t\tthrow new Error(`Unable to write enum \"${name}\", missing data.\\nReceived: \"${data}\"`);\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof data !== 'object') {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\r\n\t\t\t\t\t\t\t' | ',\r\n\t\t\t\t\t\t)}\".\\nReceived: \"${JSON.stringify(data)}\"`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet key = Object.keys(data)[0];\r\n\t\t\t\tif (key === undefined) {\r\n\t\t\t\t\tthrow new Error(`Empty object passed as invariant of the enum \"${name}\"`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet orderByte = canonicalOrder.indexOf(key);\r\n\t\t\t\tif (orderByte === -1) {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\r\n\t\t\t\t\t\t\t' | ',\r\n\t\t\t\t\t\t)}\"; received \"${key}\"`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\r\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\r\n\r\n\t\t\t\t// write order byte\r\n\t\t\t\twriter.write8(orderByte);\r\n\r\n\t\t\t\t// When { \"key\": null } - empty value for the invariant.\r\n\t\t\t\tif (invariantType === null) {\r\n\t\t\t\t\treturn writer;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\r\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\r\n\r\n\t\t\t\t{\r\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\r\n\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(\r\n\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\twriter,\r\n\t\t\t\t\t\tdata[key],\r\n\t\t\t\t\t\tparams,\r\n\t\t\t\t\t\ttypeMap,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfunction decodeEnum(this: BCS, reader: BcsReader, typeParams, typeMap) {\r\n\t\t\t\tlet orderByte = reader.readULEB();\r\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\r\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\r\n\r\n\t\t\t\tif (orderByte === -1) {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Encode an empty value for the enum.\r\n\t\t\t\tif (invariantType === null) {\r\n\t\t\t\t\treturn { [invariant]: true };\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\r\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\r\n\r\n\t\t\t\t{\r\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\t[invariant]: this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap),\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t);\r\n\t}\r\n\t/**\r\n\t * Get a set of encoders/decoders for specific type.\r\n\t * Mainly used to define custom type de/serialization logic.\r\n\t *\r\n\t * @param type\r\n\t * @returns {TypeInterface}\r\n\t */\r\n\tpublic getTypeInterface(type: string): TypeInterface {\r\n\t\tlet typeInterface = this.types.get(type);\r\n\r\n\t\t// Special case - string means an alias.\r\n\t\t// Goes through the alias chain and tracks recursion.\r\n\t\tif (typeof typeInterface === 'string') {\r\n\t\t\tlet chain: string[] = [];\r\n\t\t\twhile (typeof typeInterface === 'string') {\r\n\t\t\t\tif (chain.includes(typeInterface)) {\r\n\t\t\t\t\tthrow new Error(`Recursive definition found: ${chain.join(' -> ')} -> ${typeInterface}`);\r\n\t\t\t\t}\r\n\t\t\t\tchain.push(typeInterface);\r\n\t\t\t\ttypeInterface = this.types.get(typeInterface);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (typeInterface === undefined) {\r\n\t\t\tthrow new Error(`Type ${type} is not registered`);\r\n\t\t}\r\n\r\n\t\treturn typeInterface;\r\n\t}\r\n\r\n\t/**\r\n\t * Parse a type name and get the type's generics.\r\n\t * @example\r\n\t * let { typeName, typeParams } = parseTypeName('Option<Coin<MGO>>');\r\n\t * // typeName: Option\r\n\t * // typeParams: [ 'Coin<MGO>' ]\r\n\t *\r\n\t * @param name Name of the type to process\r\n\t * @returns Object with typeName and typeParams listed as Array\r\n\t */\r\n\tpublic parseTypeName(name: TypeName): {\r\n\t\tname: string;\r\n\t\tparams: TypeName[];\r\n\t} {\r\n\t\tif (Array.isArray(name)) {\r\n\t\t\tlet [typeName, ...params] = name;\r\n\t\t\treturn { name: typeName, params };\r\n\t\t}\r\n\r\n\t\tif (typeof name !== 'string') {\r\n\t\t\tthrow new Error(`Illegal type passed as a name of the type: ${name}`);\r\n\t\t}\r\n\r\n\t\tlet [left, right] = this.schema.genericSeparators || ['<', '>'];\r\n\r\n\t\tlet l_bound = name.indexOf(left);\r\n\t\tlet r_bound = Array.from(name).reverse().indexOf(right);\r\n\r\n\t\t// if there are no generics - exit gracefully.\r\n\t\tif (l_bound === -1 && r_bound === -1) {\r\n\t\t\treturn { name: name, params: [] };\r\n\t\t}\r\n\r\n\t\t// if one of the bounds is not defined - throw an Error.\r\n\t\tif (l_bound === -1 || r_bound === -1) {\r\n\t\t\tthrow new Error(`Unclosed generic in name '${name}'`);\r\n\t\t}\r\n\r\n\t\tlet typeName = name.slice(0, l_bound);\r\n\t\tlet params = splitGenericParameters(\r\n\t\t\tname.slice(l_bound + 1, name.length - r_bound - 1),\r\n\t\t\tthis.schema.genericSeparators,\r\n\t\t);\r\n\r\n\t\treturn { name: typeName, params };\r\n\t}\r\n}\r\n\r\n/**\r\n * Encode data with either `hex` or `base64`.\r\n *\r\n * @param {Uint8Array} data Data to encode.\r\n * @param {String} encoding Encoding to use: base64 or hex\r\n * @return {String} Encoded value.\r\n */\r\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\r\n\tswitch (encoding) {\r\n\t\tcase 'base58':\r\n\t\t\treturn toB58(data);\r\n\t\tcase 'base64':\r\n\t\t\treturn toB64(data);\r\n\t\tcase 'hex':\r\n\t\t\treturn toHEX(data);\r\n\t\tdefault:\r\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\r\n\t}\r\n}\r\n\r\n/**\r\n * Decode either `base64` or `hex` data.\r\n *\r\n * @param {String} data Data to encode.\r\n * @param {String} encoding Encoding to use: base64 or hex\r\n * @return {Uint8Array} Encoded value.\r\n */\r\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\r\n\tswitch (encoding) {\r\n\t\tcase 'base58':\r\n\t\t\treturn fromB58(data);\r\n\t\tcase 'base64':\r\n\t\t\treturn fromB64(data);\r\n\t\tcase 'hex':\r\n\t\t\treturn fromHEX(data);\r\n\t\tdefault:\r\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\r\n\t}\r\n}\r\n\r\n/**\r\n * Register the base set of primitive and common types.\r\n * Is called in the `BCS` constructor automatically but can\r\n * be ignored if the `withPrimitives` argument is not set.\r\n */\r\nexport function registerPrimitives(bcs: BCS): void {\r\n\tbcs.registerType(\r\n\t\tBCS.U8,\r\n\t\tfunction (writer: BcsWriter, data) {\r\n\t\t\treturn writer.write8(data);\r\n\t\t},\r\n\t\tfunction (reader: BcsReader) {\r\n\t\t\treturn reader.read8();\r\n\t\t},\r\n\t\t(u8) => u8 < 256,\r\n\t);\r\n\r\n\tbcs.registerType(\r\n\t\tBCS.U16,\r\n\t\tfunction (writer: BcsWriter, data) {\r\n\t\t\treturn writer.write16(data);\r\n\t\t},\r\n\t\tfunction (reader: BcsReader) {\r\n\t\t\treturn reader.read16();\r\n\t\t},\r\n\t\t(u16) => u16 < 65536,\r\n\t);\r\n\r\n\tbcs.registerType(\r\n\t\tBCS.U32,\r\n\t\tfunction (writer: BcsWriter, data) {\r\n\t\t\treturn writer.write32(data);\r\n\t\t},\r\n\t\tfunction (reader: BcsReader) {\r\n\t\t\treturn reader.read32();\r\n\t\t},\r\n\t\t(u32) => u32 <= 4294967296n,\r\n\t);\r\n\r\n\tbcs.registerType(\r\n\t\tBCS.U64,\r\n\t\tfunction (writer: BcsWriter, data) {\r\n\t\t\treturn writer.write64(data);\r\n\t\t},\r\n\t\tfunction (reader: BcsReader) {\r\n\t\t\treturn reader.read64();\r\n\t\t},\r\n\t);\r\n\r\n\tbcs.registerType(\r\n\t\tBCS.U128,\r\n\t\tfunction (writer: BcsWriter, data: bigint) {\r\n\t\t\treturn writer.write128(data);\r\n\t\t},\r\n\t\tfunction (reader: BcsReader) {\r\n\t\t\treturn reader.read128();\r\n\t\t},\r\n\t);\r\n\r\n\tbcs.registerType(\r\n\t\tBCS.U256,\r\n\t\tfunction (writer: BcsWriter, data) {\r\n\t\t\treturn writer.write256(data);\r\n\t\t},\r\n\t\tfunction (reader: BcsReader) {\r\n\t\t\treturn reader.read256();\r\n\t\t},\r\n\t);\r\n\r\n\tbcs.registerType(\r\n\t\tBCS.BOOL,\r\n\t\tfunction (writer: BcsWriter, data) {\r\n\t\t\treturn writer.write8(data);\r\n\t\t},\r\n\t\tfunction (reader: BcsReader) {\r\n\t\t\treturn reader.read8().toString(10) === '1';\r\n\t\t},\r\n\t);\r\n\r\n\tbcs.registerType(\r\n\t\tBCS.STRING,\r\n\t\tfunction (writer: BcsWriter, data: string) {\r\n\t\t\treturn writer.writeVec(Array.from(data), (writer, el) => writer.write8(el.charCodeAt(0)));\r\n\t\t},\r\n\t\tfunction (reader: BcsReader) {\r\n\t\t\treturn reader\r\n\t\t\t\t.readVec((reader) => reader.read8())\r\n\t\t\t\t.map((el: bigint) => String.fromCharCode(Number(el)))\r\n\t\t\t\t.join('');\r\n\t\t},\r\n\t\t(_str: string) => true,\r\n\t);\r\n\r\n\tbcs.registerType(\r\n\t\tBCS.HEX,\r\n\t\tfunction (writer: BcsWriter, data: string) {\r\n\t\t\treturn writer.writeVec(Array.from(fromHEX(data)), (writer, el) => writer.write8(el));\r\n\t\t},\r\n\t\tfunction (reader: BcsReader) {\r\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\r\n\t\t\treturn toHEX(new Uint8Array(bytes));\r\n\t\t},\r\n\t);\r\n\r\n\tbcs.registerType(\r\n\t\tBCS.BASE58,\r\n\t\tfunction (writer: BcsWriter, data: string) {\r\n\t\t\treturn writer.writeVec(Array.from(fromB58(data)), (writer, el) => writer.write8(el));\r\n\t\t},\r\n\t\tfunction (reader: BcsReader) {\r\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\r\n\t\t\treturn toB58(new Uint8Array(bytes));\r\n\t\t},\r\n\t);\r\n\r\n\tbcs.registerType(\r\n\t\tBCS.BASE64,\r\n\t\tfunction (writer: BcsWriter, data: string) {\r\n\t\t\treturn writer.writeVec(Array.from(fromB64(data)), (writer, el) => writer.write8(el));\r\n\t\t},\r\n\t\tfunction (reader: BcsReader) {\r\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\r\n\t\t\treturn toB64(new Uint8Array(bytes));\r\n\t\t},\r\n\t);\r\n}\r\n\r\nexport function getRustConfig(): BcsConfig {\r\n\treturn {\r\n\t\tgenericSeparators: ['<', '>'],\r\n\t\tvectorType: 'Vec',\r\n\t\taddressLength: MGO_ADDRESS_LENGTH,\r\n\t\taddressEncoding: 'hex',\r\n\t};\r\n}\r\n\r\nexport function getMgoMoveConfig(): BcsConfig {\r\n\treturn {\r\n\t\tgenericSeparators: ['<', '>'],\r\n\t\tvectorType: 'vector',\r\n\t\taddressLength: MGO_ADDRESS_LENGTH,\r\n\t\taddressEncoding: 'hex',\r\n\t};\r\n}\r\n\r\nexport function splitGenericParameters(\r\n\tstr: string,\r\n\tgenericSeparators: [string, string] = ['<', '>'],\r\n) {\r\n\tconst [left, right] = genericSeparators;\r\n\tconst tok = [];\r\n\tlet word = '';\r\n\tlet nestedAngleBrackets = 0;\r\n\r\n\tfor (let i = 0; i < str.length; i++) {\r\n\t\tconst char = str[i];\r\n\t\tif (char === left) {\r\n\t\t\tnestedAngleBrackets++;\r\n\t\t}\r\n\t\tif (char === right) {\r\n\t\t\tnestedAngleBrackets--;\r\n\t\t}\r\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\r\n\t\t\ttok.push(word.trim());\r\n\t\t\tword = '';\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tword += char;\r\n\t}\r\n\r\n\ttok.push(word.trim());\r\n\r\n\treturn tok;\r\n}\r\n","function b64ToUint6(nChr: number) {\r\n\treturn nChr > 64 && nChr < 91\r\n\t\t? nChr - 65\r\n\t\t: nChr > 96 && nChr < 123\r\n\t\t? nChr - 71\r\n\t\t: nChr > 47 && nChr < 58\r\n\t\t? nChr + 4\r\n\t\t: nChr === 43\r\n\t\t? 62\r\n\t\t: nChr === 47\r\n\t\t? 63\r\n\t\t: 0;\r\n}\r\n\r\nexport function fromB64(sBase64: string, nBlocksSize?: number): Uint8Array {\r\n\tvar sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ''),\r\n\t\tnInLen = sB64Enc.length,\r\n\t\tnOutLen = nBlocksSize\r\n\t\t\t? Math.ceil(((nInLen * 3 + 1) >> 2) / nBlocksSize) * nBlocksSize\r\n\t\t\t: (nInLen * 3 + 1) >> 2,\r\n\t\ttaBytes = new Uint8Array(nOutLen);\r\n\r\n\tfor (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\r\n\t\tnMod4 = nInIdx & 3;\r\n\t\tnUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << (6 * (3 - nMod4));\r\n\t\tif (nMod4 === 3 || nInLen - nInIdx === 1) {\r\n\t\t\tfor (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\r\n\t\t\t\ttaBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;\r\n\t\t\t}\r\n\t\t\tnUint24 = 0;\r\n\t\t}\r\n\t}\r\n\r\n\treturn taBytes;\r\n}\r\n\r\n/* Base64 string to array encoding */\r\n\r\nfunction uint6ToB64(nUint6: number) {\r\n\treturn nUint6 < 26\r\n\t\t? nUint6 + 65\r\n\t\t: nUint6 < 52\r\n\t\t? nUint6 + 71\r\n\t\t: nUint6 < 62\r\n\t\t? nUint6 - 4\r\n\t\t: nUint6 === 62\r\n\t\t? 43\r\n\t\t: nUint6 === 63\r\n\t\t? 47\r\n\t\t: 65;\r\n}\r\n\r\nexport function toB64(aBytes: Uint8Array): string {\r\n\tvar nMod3 = 2,\r\n\t\tsB64Enc = '';\r\n\r\n\tfor (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\r\n\t\tnMod3 = nIdx % 3;\r\n\t\tnUint24 |= aBytes[nIdx] << ((16 >>> nMod3) & 24);\r\n\t\tif (nMod3 === 2 || aBytes.length - nIdx === 1) {\r\n\t\t\tsB64Enc += String.fromCodePoint(\r\n\t\t\t\tuint6ToB64((nUint24 >>> 18) & 63),\r\n\t\t\t\tuint6ToB64((nUint24 >>> 12) & 63),\r\n\t\t\t\tuint6ToB64((nUint24 >>> 6) & 63),\r\n\t\t\t\tuint6ToB64(nUint24 & 63),\r\n\t\t\t);\r\n\t\t\tnUint24 = 0;\r\n\t\t}\r\n\t}\r\n\r\n\treturn (\r\n\t\tsB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? '' : nMod3 === 1 ? '=' : '==')\r\n\t);\r\n}\r\n","export function fromHEX(hexStr: string): Uint8Array {\r\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\r\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\r\n\tconst intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\r\n\r\n\treturn Uint8Array.from(intArr);\r\n}\r\n\r\nexport function toHEX(bytes: Uint8Array): string {\r\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\r\n}\r\n"],"mappings":"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","names":["writer","name","params","reader","typeName"]}